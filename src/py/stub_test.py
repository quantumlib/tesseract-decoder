# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests that validate the pre-generated .pyi stub files for tesseract_decoder.

These stubs are generated by `bazel run //src:generate_stubs -- --output-dir src`
and committed to the repository under `src/tesseract_decoder-stubs/`. This test
validates that the stubs exist, are syntactically valid Python, and contain
the expected symbols.
"""

import ast
import glob
import os

import pytest


def _find_stub_files():
    """Find all .pyi stub files in the data runfiles."""
    # Find the src/tesseract_decoder-stubs/*.pyi files in the Bazel tree.
    pattern = os.path.join(
            os.environ["TEST_SRCDIR"],
            os.environ["TEST_WORKSPACE"],
            "src",
            "tesseract_decoder-stubs",
            "*.pyi",
        )
    return glob.glob(pattern)


def _collect_all_names(pyi_files):
    """Collect all defined names from a list of .pyi files."""
    all_names = set()
    for stub_path in pyi_files:
        with open(stub_path, "r") as f:
            content = f.read()
        tree = ast.parse(content)
        for node in ast.walk(tree):
            if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
                all_names.add(node.name)
            elif isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        all_names.add(target.id)
            elif isinstance(node, ast.ImportFrom):
                if node.names:
                    for alias in node.names:
                        all_names.add(
                            alias.name if alias.asname is None else alias.asname
                        )
    return all_names


@pytest.fixture(scope="session")
def stub_files():
    """Collect all generated .pyi stub files."""
    files = _find_stub_files()
    if not files:
        pytest.skip(
            "No .pyi stub files found. Run "
            "'bazel run //src:generate_stubs -- --output-dir src' first."
        )
    return files


class TestStubFilesExist:
    """Tests that stub files exist and are valid Python."""

    def test_stubs_generated(self, stub_files):
        """At least one .pyi stub file should exist."""
        assert len(stub_files) > 0

    EXPECTED_STUBS = [
        "__init__.pyi",
        "common.pyi",
        "simplex.pyi",
        "tesseract.pyi",
        "tesseract_sinter_compat.pyi",
        "utils.pyi",
        "viz.pyi",
    ]

    @pytest.mark.parametrize("filename", EXPECTED_STUBS)
    def test_expected_stub_exists(self, stub_files, filename):
        """Each expected submodule stub file should be generated."""
        basenames = [os.path.basename(f) for f in stub_files]
        assert filename in basenames, (
            f"Missing expected stub file: {filename}. "
            f"Found: {basenames}"
        )

    def test_stubs_are_valid_python(self, stub_files):
        """All .pyi files should be parseable as valid Python."""
        for stub_path in stub_files:
            with open(stub_path, "r") as f:
                content = f.read()
            try:
                ast.parse(content)
            except SyntaxError as e:
                basename = os.path.basename(stub_path)
                pytest.fail(f"Stub file {basename} has invalid syntax: {e}")


class TestStubContents:
    """Tests that the generated stubs contain the expected symbols."""

    EXPECTED_SYMBOLS = [
        "Symptom",
        "Error",
        "TesseractConfig",
        "TesseractDecoder",
        "TesseractSinterCompiledDecoder",
        "TesseractSinterDecoder",
        "SimplexConfig",
        "SimplexDecoder",
        "DetOrder",
        "Visualizer",
        "make_tesseract_sinter_decoders_dict",
    ]

    @pytest.mark.parametrize("symbol", EXPECTED_SYMBOLS)
    def test_expected_symbol_in_stubs(self, stub_files, symbol):
        """Key symbols from the pybind11 module should appear in stubs."""
        all_names = _collect_all_names(stub_files)
        assert symbol in all_names, (
            f"Expected symbol '{symbol}' not found in stub files. "
            f"Found names: {sorted(all_names)}"
        )


if __name__ == "__main__":
    raise SystemExit(pytest.main([__file__]))
